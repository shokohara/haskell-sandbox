module Sandbox where

import Data.List (sort, sortBy, find)
import Data.Maybe (fromJust, maybeToList)
import Debug.Trace
import Data.Matrix

function :: [[Integer]] -> [[Integer]]
function xss = concat $ map (toSquare [[]]) xss

m = [[[0,1,2],[3,4,5],[6,7,8]]
  ,[[10,11,12],[13,14,15],[16,17,18]]
  ,[[20,21,22],[23,24,25],[26,27,28]]
  ,[[30,31,32],[33,34,35],[36,37,38]]
  ,[[40,41,42],[43,44,45],[46,47,48]]
  ,[[50,51,52],[53,54,55],[56,57,58]]
  ,[[60,61,62],[63,64,65],[66,67,68]]
  ,[[70,71,72],[73,74,75],[76,77,78]]
  ,[[80,81,82],[83,84,85],[86,87,88]]]

f = . toLists . transpose . fromLists $ m

-- [[0,1,2],[3,4,5],[6,7,8]
-- ,[10,11,12],[13,14,15],[16,17,18]
-- ,[20,21,22],[23,24,25],[26,27,28]
-- ,[30,31,32],[33,34,35],[36,37,38]
-- ,[40,41,42],[43,44,45],[46,47,48]
-- ,[50,51,52],[53,54,55],[56,57,58]
-- ,[60,61,62],[63,64,65],[66,67,68]
-- ,[70,71,72],[73,74,75],[76,77,78]
-- ,[80,81,82],[83,84,85],[86,87,88]]

-- [[3,4,5],[6,7,8]
-- ,[13,14,15],[16,17,18]
-- ,[23,24,25],[26,27,28]
-- ,[30,31,32],[33,34,35],[36,37,38]
-- ,[40,41,42],[43,44,45],[46,47,48]
-- ,[50,51,52],[53,54,55],[56,57,58]
-- ,[60,61,62],[63,64,65],[66,67,68]
-- ,[70,71,72],[73,74,75],[76,77,78]
-- ,[80,81,82],[83,84,85],[86,87,88]]
--
-- [[[0,1,2],[3,4,5],[6,7,8]]
-- ,[[10,11,12],[13,14,15],[16,17,18]]
-- ,[[20,21,22],[23,24,25],[26,27,28]]
-- ,[[30,31,32],[33,34,35],[36,37,38]]
-- ,[[40,41,42],[43,44,45],[46,47,48]]
-- ,[[50,51,52],[53,54,55],[56,57,58]]
-- ,[[60,61,62],[63,64,65],[66,67,68]]
-- ,[[70,71,72],[73,74,75],[76,77,78]]
-- ,[[80,81,82],[83,84,85],[86,87,88]]]
-- [[[3,4,5],[6,7,8]]
-- ,[[13,14,15],[16,17,18]]
-- ,[[23,24,25],[26,27,28]]
-- ,[[30,31,32],[33,34,35],[36,37,38]]
-- ,[[40,41,42],[43,44,45],[46,47,48]]
-- ,[[50,51,52],[53,54,55],[56,57,58]]
-- ,[[60,61,62],[63,64,65],[66,67,68]]
-- ,[[70,71,72],[73,74,75],[76,77,78]]
-- ,[[80,81,82],[83,84,85],[86,87,88]]]


--f xs = map (take 1) $ take 1 xs
--f :: [[Integer]] -> [[Integer]] -> [[Integer]] -> [[[Integer]]] -> [Integer]
--f rr r [] [] = concat rr
--f rr r wr xs = if length r == 3
--                  then f (rr ++ r) [] [] (wr ++ xs)
--                  else f rr (r ++ take 1 . take 1 $ xs) (wr ++ (drop 1 . take 1 xs)) (drop 3 xs)

g :: [[Integer]] -> [[Integer]] -> [[Integer]] -> [[[Integer]]]
g r wr [] = [r, [], wr]
g r wr xs = [filter (/= []) (r ++ take 1 xs), filter (/= []) (wr ++ (take 2 . drop 1 $ xs)), filter (/= []) (drop 3 xs)]

--function :: [[Integer]] -> [[Integer]]
--function xss = xss

toSquare :: [[Integer]] -> [Integer] -> [[Integer]]
toSquare r [] = drop 1 r
toSquare r xs = toSquare (r ++ [take 3 xs]) (drop 3 xs)
